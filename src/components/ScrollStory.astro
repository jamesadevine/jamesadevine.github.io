---
// ScrollStory.astro - Simple scroll-driven story component
import "../styles/global.css";
export interface StoryPanel {
    content?: string;
    backgroundColor: string;
    textColor?: string;
}

interface Props {
    panels: StoryPanel[];
}

const { panels }: Props = Astro.props;
---

<div class="scroll-story" data-panels={JSON.stringify(panels)}>
    {
        panels.map((panel, index) => (
            <div class="story-panel" data-index={index}>
                <div class="panel-content">
                    {panel.content && <div set:html={panel.content} />}
                </div>
            </div>
        ))
    }
</div>

<style>
    .scroll-story {
        position: relative;
        width: 100%;
    }

    .story-panel {
        height: 100vh;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        transition: all 0.3s ease;
    }

    .panel-content {
        max-width: 800px;
        padding: 2rem;
        text-align: center;
        z-index: 1;
        font-size: 5rem;
    }
</style>

<script>
    class ScrollStoryComponent {
        private container: HTMLElement;
        private panels: any[];
        private currentPanelIndex: number = 0;
        private restoreColor: string;

        constructor(container: HTMLElement) {
            this.container = container;
            this.panels = JSON.parse(container.dataset.panels || "[]");
            // get restore color from parent element
            this.restoreColor =
                this.container.parentElement?.style.getPropertyValue(
                    "background-color",
                ) || "#ffffff";
            // this.restoreColor = this.rgbToHex(
            //     restoreColor.r,
            //     restoreColor.g,
            //     restoreColor.b,
            // );
            this.init();
        }

        private init() {
            this.handleScroll = this.handleScroll.bind(this);
            window.addEventListener("scroll", this.handleScroll);
            this.handleScroll(); // Initial call
        }

        private handleScroll() {
            const scrollTop = window.pageYOffset;
            const windowHeight = window.innerHeight;
            const containerTop = this.container.offsetTop;
            const containerHeight = this.container.offsetHeight;

            // Calculate which panel we're currently viewing
            const relativeScroll = scrollTop - containerTop;
            const panelIndex = Math.floor(relativeScroll / windowHeight);
            const normalizedIndex = Math.max(
                0,
                Math.min(panelIndex, this.panels.length),
            );

            // Calculate scroll progress within the current panel
            const panelProgress =
                (relativeScroll % windowHeight) / windowHeight;

            this.updateColors(normalizedIndex, panelProgress);
        }

        private updateColors(panelIndex: number, progress: number) {
            if (panelIndex !== this.currentPanelIndex) {
                this.currentPanelIndex = panelIndex;
            }

            // Get current panel colors
            const currentPanel = this.panels[panelIndex];

            // If we're past all story panels, use original colors as the "current" panel
            let backgroundColor: string;
            let textColor: string;

            if (panelIndex === this.panels.length) {
                console.log(
                    `Reached end of story panels, using restore color ${this.restoreColor}`,
                );
                return;
                // We're in the fade-out panel - fade to original background color
                // backgroundColor = this.originalContainerBackgroundColor;
                // textColor = this.originalContainerBackgroundColor; // Text fades to background color
            } else {
                backgroundColor = currentPanel.backgroundColor;
                textColor = currentPanel.textColor || "#000000";
            }

            // Check if we should transition to the next panel, fade-out panel, or original colors
            if (progress > 0) {
                let nextBackgroundColor: string;
                let nextTextColor: string;

                if (panelIndex === this.panels.length - 1) {
                    // Next "panel" is the fade-out panel
                    nextBackgroundColor = this.restoreColor;
                    nextTextColor = this.restoreColor; // Text fades to background
                    console.log(
                        `Transitioning to fade-out panel ${panelIndex} ${nextBackgroundColor} ${nextTextColor}`,
                    );
                } else {
                    // Next panel is another story panel
                    const nextPanel = this.panels[panelIndex + 1];
                    nextBackgroundColor = nextPanel.backgroundColor;
                    nextTextColor = nextPanel.textColor || "#000000";
                }

                const transitionProgress = progress;
                backgroundColor = this.interpolateColor(
                    backgroundColor,
                    nextBackgroundColor,
                    transitionProgress,
                );
                textColor = this.interpolateColor(
                    textColor,
                    nextTextColor,
                    transitionProgress,
                );
            }

            this.container.style.setProperty(
                "background-color",
                backgroundColor,
                "important",
            );

            this.container.style.setProperty("color", textColor, "important");
        }

        private interpolateColor(
            color1: string,
            color2: string,
            factor: number,
        ): string {
            // Convert hex colors to RGB
            const rgb1 = this.hexToRgb(color1);
            const rgb2 = this.hexToRgb(color2);

            if (!rgb1 || !rgb2) return color1;

            // Interpolate each RGB component
            const r = Math.round(rgb1.r + (rgb2.r - rgb1.r) * factor);
            const g = Math.round(rgb1.g + (rgb2.g - rgb1.g) * factor);
            const b = Math.round(rgb1.b + (rgb2.b - rgb1.b) * factor);

            return `rgb(${r}, ${g}, ${b})`;
        }
        private hexToRgb(
            hex: string,
        ): { r: number; g: number; b: number } | null {
            // Handle both #RGB and #RRGGBB formats
            const result =
                /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex) ||
                /^#?([a-f\d])([a-f\d])([a-f\d])$/i.exec(hex);

            if (!result) return null;

            if (result[1].length === 1) {
                // Short format (#RGB)
                return {
                    r: parseInt(result[1] + result[1], 16),
                    g: parseInt(result[2] + result[2], 16),
                    b: parseInt(result[3] + result[3], 16),
                };
            } else {
                // Long format (#RRGGBB)
                return {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16),
                };
            }
        }

        destroy() {
            window.removeEventListener("scroll", this.handleScroll);
        }
    }

    // Initialize the component when the DOM is loaded
    document.addEventListener("DOMContentLoaded", () => {
        const scrollStories = document.querySelectorAll(".scroll-story");

        const rgbString = window
            .getComputedStyle(document.body)
            .getPropertyValue("--gray-light");

        const rgbValues = rgbString
            .split(",")
            .map((val) => parseInt(val.trim()));

        scrollStories.forEach((container) => {
            new ScrollStoryComponent(container as HTMLElement);
        });
    });

    // Also initialize if the script runs after DOM is already loaded
    if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", () => {
            const scrollStories = document.querySelectorAll(".scroll-story");
            const rgbString = window
                .getComputedStyle(document.body)
                .getPropertyValue("--gray-light");

            const rgbValues = rgbString
                .split(",")
                .map((val) => parseInt(val.trim()));

            scrollStories.forEach((container) => {
                new ScrollStoryComponent(container as HTMLElement);
            });
        });
    } else {
        const scrollStories = document.querySelectorAll(".scroll-story");
        const rgbString = window
            .getComputedStyle(document.body)
            .getPropertyValue("--gray-light");

        const rgbValues = rgbString
            .split(",")
            .map((val) => parseInt(val.trim()));

        scrollStories.forEach((container) => {
            new ScrollStoryComponent(container as HTMLElement);
        });
    }
</script>
